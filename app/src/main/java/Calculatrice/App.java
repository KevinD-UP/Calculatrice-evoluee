/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package Calculatrice;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import Model.Boolean.Boolean;
import Model.Boolean.BooleanStack;
import Model.Boolean.OperatorBoolean;
import Model.Double.DoubleStack;
import Model.Fraction.FractionStack;
import Model.Set.SetStack;
import com.github.kiprobinson.bigfraction.BigFraction;
import org.mariuszgromada.math.mxparser.*;

/**
 * Classe principal.
 */
public final class App {

    /**
     * Liste de commande
     */
    private static final String QUIT      = "exit";   //Quitte le programme
    private static final String VAR       = "var";    //Regarde la liste des variables
    private static final String CLEAR     = "clear";  //Vide la pile et la liste des variables et l'historique
    private static final String PILE      = "pile";   //Visualise la pile
    private static final String STACK     = "stack";   //Visualise la pile
    private static final String SWITCH    = "switch"; //Permet de changer de mode
    private static final String CHECKMODE = "mode";   //Affiche le mode actuel
    private static final String HIST      = "hist";   //Affiche le contenu de l'historique
    private static final String HELP      = "help";   //Affiche l'aide

    /**
     * 0: Mode RPN, 1: Mode Algébrique, 2: Mode booléen, 3: Mode Ensemble, 4: Mode Fraction.
     */
    private static int MODE = 0;

    /**
     * Pile de valeur
     */
    private static final DoubleStack   DOUBLE_STACK   = DoubleStack.generate();
    private static final BooleanStack  BOOLEAN_STACK  = BooleanStack.generate();
    private static final SetStack      SET_STACK      = SetStack.generate();
    private static final FractionStack FRACTION_STACK = FractionStack.generate();


    /**
     * Procédure permettant d'analyser la chaîne de caractère entrée dans le terminal
     * @param s Chaîne de caratère entré par l'utilisateur
     */
    public static void evaluate(String s) {
        switch (s.trim()) {
            case HELP -> help();
            case HIST -> hist();
            case QUIT -> quit();
            case CHECKMODE -> checkmode();
            case SWITCH -> switchmode();
            case VAR -> printVar();
            case CLEAR -> clear();
            case STACK, PILE -> printStack();
            default -> calculate(s);
        }
    }

    /**
     * Effectue le calcul en fonction du mode.
     * @param s Chaîne entré par l'utilisateur
     */
    private static void calculate(String s){
        if (MODE == 0) calculateRPN(s);
        else if (MODE == 1) calculateAlgebr(s);
        else if (MODE == 2) calculateBool(s);
        else if (MODE == 3) calculateSet(s);
        else if (MODE == 4) calculateFraction(s);
    }

    /**
     * Quitte le programme
     */
    private static void quit(){
        System.out.println("><><><><><>Arrêt de la calculatrice<><><><><><><><><><><><><><><><");
        System.exit(0);

    }

    /**
     * Affiche le mode actuel
     */
    private static void checkmode() {
        switch (MODE) {
            case 0 -> System.out.println("\t Actuellement en mode RPN");
            case 1 -> System.out.println("\t Actuellement en mode Algébrique");
            case 2 -> System.out.println("\t Actuellement en mode Booléen");
            case 3 -> System.out.println("\t Actuellement en mode Ensemble");
            case 4 -> System.out.println("\t Actuellement en mode Fraction");
            default -> throw new IllegalStateException("Unexpected value: " + MODE);
        }
    }

    /**
     * Affiche l'état actuel de la pile
     */
    private static void printStack(){
        if (MODE == 0 || MODE == 1) {
            DOUBLE_STACK.print();
        }else if (MODE == 2){
            BOOLEAN_STACK.print();
        }else if (MODE == 3){
            SET_STACK.print();
        }else if (MODE == 4){
            FRACTION_STACK.print();
        }
    }

    /**
     * Affiche l'aide pour l'utilisateur
     */
    private static void help(){
        System.out.println("><><><><><>Aide pour l'utilisateur<><><><><><><><><><><><><><><><");
        System.out.println("\t - exit:   Quitte le programme");
        System.out.println("\t - var:    Regarde la liste des variables");
        System.out.println("\t - clear:  Vide la pile, la liste des variables et l'historique");
        System.out.println("\t - stack:  Visualise la pile");
        System.out.println("\t - switch: Permet de changer de mode");
        System.out.println("\t - mode:   Affiche le mode actuel");
        System.out.println("\t - hist:   Affiche le contenu de l'historique");
        System.out.println("\t - help:   Affiche l'aide");
        System.out.println("><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><");
    }

    /**
     * Vide la pile, l'historique et les variables en fonction du mode
     */
    private static void clear(){
        if(MODE == 0 || MODE == 1) {
            DOUBLE_STACK.clear();
            System.out.println("\t Variable, Historique et Pile vidées");
        }else if (MODE == 2){
            BOOLEAN_STACK.clear();
            System.out.println("\t Variable, Historique et Pile vidées");
        }else if (MODE == 3){
            SET_STACK.clear();
            System.out.println("\t Variable, Historique et Pile vidées");
        }else if (MODE == 4){
            FRACTION_STACK.clear();
            System.out.println("\t Variable, Historique et Pile vidées");
        }
    }

    /**
     * Affiche l'historique en fonction du mode
     */
    private static void hist(){
        if (MODE == 0 || MODE == 1) {
            Iterator<String> iterator = DOUBLE_STACK.descendingIteratorHist();
            for(int i = 0; i < DOUBLE_STACK.sizeHisto(); i++) {
                System.out.println("\t hist(" + i + "): " + iterator.next());
            }
        }else if (MODE == 2){
            Iterator<String> iterator = BOOLEAN_STACK.descendingIteratorHist();
            for(int i = 0; i < BOOLEAN_STACK.sizeHisto(); i++) {
                System.out.println("\t hist(" + i + "): " + iterator.next());

            }
        }else if (MODE == 3){
            Iterator<String> iterator = SET_STACK.descendingIteratorHist();
            for(int i = 0; i < SET_STACK.sizeHisto(); i++) {
                System.out.println("\t hist(" + i + "): " + iterator.next());
            }
        }else if (MODE == 4){
            Iterator<String> iterator = FRACTION_STACK.descendingIteratorHist();
            for(int i = 0; i < FRACTION_STACK.sizeHisto(); i++) {
                System.out.println("\t hist(" + i + "): " + iterator.next());
            }
        }
    }

    private static void switchmode(){
        Scanner scan1 = new Scanner(System.in);
        System.out.println("\t Choisissez le mode voulu (entrer le chiffre): \n \t- 0: RPN \n \t- 1: Algébrique \n \t- 2: Booléen \n \t- 3: Ensemble \n \t- 4: Fraction");
        boolean inputNotNull = true;
        while (inputNotNull) {
            try {
                int mode = scan1.nextInt();
                inputNotNull = false;
                switch (mode) {
                    case 0 -> {
                        MODE = 0;
                        System.out.println("\t Passage en mode RPN");
                    }
                    case 1 -> {
                        MODE = 1;
                        System.out.println("\t Passage en mode Algébrique");
                    }
                    case 2 -> {
                        MODE = 2;
                        System.out.println("\t Passage en mode Booléen");
                    }
                    case 3 -> {
                        MODE = 3;
                        System.out.println("\t Passage en mode Ensemble");
                    }
                    case 4 -> {
                        MODE = 4;
                        System.out.println("\t Passage en mode Fraction");
                    }
                    default -> System.out.println("\t Mode inchangé");
                }
            } catch (InputMismatchException e) {
                System.err.println("\t Erreur ! Veuillez entrer un chiffre correspondant à un mode");
                scan1.nextLine();
            }
        }
    }

    private static void printVar(){
        if(MODE == 0 || MODE == 1) { DOUBLE_STACK.printVariable(); }
        else if(MODE == 2) { BOOLEAN_STACK.printVariable(); }
        else if(MODE == 3) { SET_STACK.printVariable(); }
        else if(MODE == 4) { FRACTION_STACK.printVariable(); }
    }

/*
=============================================================================================================
                                        CALCUL DES FRACTIONS
=============================================================================================================
 */

    /**
     * Calcul des fractions
     * @param s Chaîne entré par l'utilisateur
     */
    public static void calculateFraction(String s){
        boolean finished = false;
        //Formatage de l'input
        ArrayList<String> input = new ArrayList<>();
        Collections.addAll(input, s.trim().split(" "));
        if(input.size() == 1){
            s = FRACTION_STACK.hp(s);
            s = FRACTION_STACK.var(s);
            input = new ArrayList<>();
            Collections.addAll(input, s.trim().split(" "));
        }
        input.removeAll(Arrays.asList(null, ""));

        if(input.size() != 0) {
            if (input.size() == 1) {
                /*
                 * Execution de l'opération si la chaîne entré est un unique opérateur.
                 * Il est nécessaire de vérifier qu'il existe assez d'opérandes dans la pile.
                 */
                if (FRACTION_STACK.isOperator(input.get(0))) {
                    if (FRACTION_STACK.size() >= 2) {
                        FRACTION_STACK.push(FRACTION_STACK.doOperation(s));
                        FRACTION_STACK.pushHist( String.valueOf(FRACTION_STACK.peek()));
                        assert FRACTION_STACK.peek() != null;
                        System.out.println("\t " + FRACTION_STACK.peek());
                    } else {
                        System.out.println("\t Nombre d'opérandes dans la pile insuffisant");
                    }
                }else{
                    try {
                        FRACTION_STACK.push(FRACTION_STACK.getValue(s));
                        FRACTION_STACK.pushHist( String.valueOf(FRACTION_STACK.peek()));
                        assert FRACTION_STACK.peek() != null;
                        System.out.println("\t " + FRACTION_STACK.peek());
                    }catch (ArithmeticException e){
                        System.out.println("\t Division par 0 non autorisée");
                    }catch (IllegalArgumentException e){
                        System.out.println("\t Argument non autorisé");
                    }
                }
            }else{
                boolean hasVariableAssignment = input.contains("=");
                String var = "";
                int startIndex;
                if (hasVariableAssignment) {
                    var = input.get(0);
                    startIndex = 2;
                } else {
                    startIndex = 0;
                }
                for (int i = startIndex; i < input.size(); i++) {
                    String n = input.get(i);
                    n = FRACTION_STACK.hp(n);
                    n = FRACTION_STACK.var(n);
                    /* Réalisation du calcul */
                    if (FRACTION_STACK.isOperator(n)) {
                        if (FRACTION_STACK.size() > 1) {
                            FRACTION_STACK.push(FRACTION_STACK.doOperation(n));
                            FRACTION_STACK.pushHist( String.valueOf(FRACTION_STACK.peek()));
                            assert FRACTION_STACK.peek() != null;
                        }else{
                            System.out.println("\t Nombre d'opérandes dans la pile insuffisant");
                        }
                    }else{
                        try{
                            BigFraction f = FRACTION_STACK.getValue(n);
                            FRACTION_STACK.push(f);
                            FRACTION_STACK.pushHist( String.valueOf(FRACTION_STACK.peek()));
                        }catch (ArithmeticException e){
                            System.out.println("\t Division par 0 non autorisée");
                            finished=true;
                        }
                    }
                }
                if (!finished) {
                    BigFraction result = FRACTION_STACK.peek();
                    if (hasVariableAssignment) {
                        FRACTION_STACK.pop();
                        FRACTION_STACK.replaceAddValue(var, result);
                        System.out.println("\t " + var +" - " + result);
                    }else{
                        System.out.println("\t " + FRACTION_STACK.peek());
                    }
                }
            }
        }
    }

/*
=============================================================================================================
                                        CALCUL DES ENSEMBLES
=============================================================================================================
 */

    /**
     * Calcul des ensembles
     * @param s chaînes entrée par l'utilisateur
     */
    public static void calculateSet(String s) {
        boolean finished = false;
        //Formatage de l'input
        ArrayList<String> input = new ArrayList<>();
        Collections.addAll(input, s.trim().split(" "));

        if(input.size()==1){
            if(s.contains("!") || s.contains("?")) {
                s = s.replace(" ","");
                s = SET_STACK.var(s);
            }else{
                s = SET_STACK.hp(s);
                s = s.replace(" ","");
            }
            input = new ArrayList<>();
            Collections.addAll(input, s.trim().split(" "));
        }else if (input.size() > 1 && s.contains("!")){
            System.out.println("\t Erreur de syntaxe !variable ne peut pas être avec d'autre arguments");
            return;
        }

        input.removeAll(Arrays.asList(null, ""));
        //Touche entré de l'utilisateur
        if (input.size() != 0) {
            if (input.size() == 1) {
                /*
                 * Execution de l'opération si la chaîne entré est un unique opérateur.
                 * Il est nécessaire de vérifier qu'il existe assez d'opérandes dans la pile.
                 */
                if (SET_STACK.isOperator(input.get(0))) {
                    if (SET_STACK.size() >= 2) {
                        SET_STACK.push(SET_STACK.doOperation(s));
                        SET_STACK.pushHist( String.valueOf(SET_STACK.peek()));
                        assert SET_STACK.peek() != null;
                        System.out.println("\t " + Arrays.toString(SET_STACK.peek().toArray()));
                    } else {
                        System.out.println("\t Nombre d'opérandes dans la pile insuffisant");
                    }
                } else { // Stockage dans la pile si la chaine entré est une valeur.
                    HashSet<Double> val = SET_STACK.getValue(s);
                    if (!val.contains(Double.NaN)) {
                        SET_STACK.push(val);
                        SET_STACK.pushHist( String.valueOf(SET_STACK.peek()));
                        assert SET_STACK.peek() != null;
                        System.out.println("\t " + Arrays.toString(SET_STACK.peek().toArray()));
                    } else {
                        System.out.println("\t Pas un ensemble");
                    }
                }
            } else {
                boolean hasVariableAssignment = input.contains("=");
                String var = "";
                int startIndex;
                if (hasVariableAssignment) {
                    var = input.get(0);
                    if(containOnlyNumber(var)){
                        System.out.println("\t Nom de variable non acceptable");
                        return;
                    }
                    startIndex = 2;
                } else {
                    startIndex = 0;
                }
                for (int i = startIndex; i < input.size(); i++) {
                    String n = input.get(i);
                    n = SET_STACK.hp(n);
                    n = SET_STACK.var(n);
                    n = n.replace(" ","");
                    //Réalisation du calcul
                    if (SET_STACK.isOperator(n)) {
                        if (SET_STACK.size() > 1) {
                            HashSet<Double> val = SET_STACK.doOperation(n);
                            if (!val.contains(Double.NaN)) {
                                SET_STACK.push(val);
                                SET_STACK.pushHist( String.valueOf(SET_STACK.peek()));
                            }
                        } else {
                            System.out.println("\t Operation non valide!");
                            finished = true;
                            break;
                        }
                    } else {
                        HashSet<Double> val = SET_STACK.getValue(n);
                        if (!val.contains(Double.NaN)) {
                            SET_STACK.push(val);
                            SET_STACK.pushHist( String.valueOf(SET_STACK.peek()));
                        } else {
                            finished = true;
                            break;
                        }
                    }
                }
                if (!finished) {
                    HashSet<Double> result = SET_STACK.peek();
                    if (hasVariableAssignment) {
                        SET_STACK.pop();
                        SET_STACK.replaceAddValue(var, result);
                        System.out.println("\t " + var +" - " + result);
                    }else{
                        System.out.println("\t " + Arrays.toString(SET_STACK.peek().toArray()));
                    }
                }
            }
        }
    }

/*
=============================================================================================================
                                        CALCUL DES BOOLEENS
=============================================================================================================
*/

    /**
     * Calcul de booléen
     * @param s Chaîne entrée par l'utilisateur
     */
    public static void calculateBool(String s) {
        boolean finished = false;
        //Formatage de l'input

        ArrayList<String> input = new ArrayList<>();
        Collections.addAll(input, s.trim().split(" "));

        if(input.size()==1){
          s = BOOLEAN_STACK.hp(s);
          s = BOOLEAN_STACK.var(s);
          input = new ArrayList<>();
          Collections.addAll(input, s.trim().split(" "));
        }else if (input.size() > 1 && s.contains("!")){
            System.out.println("\t Erreur de syntaxe !variable ne peut pas être avec d'autre arguments");
            return;
        }
        input.removeAll(Arrays.asList(null, ""));

        if (input.size() != 0) {
            if (input.size() == 1) {
                /*
                 * Execution de l'opération si la chaîne entré est un unique opérateur.
                 * Il est nécessaire de vérifier qu'il existe assez d'opérandes dans la pile.
                 */
                if (BOOLEAN_STACK.isOperator(input.get(0))) {
                    if (s.toUpperCase().equals(OperatorBoolean.NOT.getOperator())) {
                        if (BOOLEAN_STACK.size() >= 1) {
                            BOOLEAN_STACK.push(BOOLEAN_STACK.doOperation(s));
                            BOOLEAN_STACK.pushHist( String.valueOf(BOOLEAN_STACK.peek()));
                            System.out.println("\t " + BOOLEAN_STACK.peek().getValue());
                        } else {
                            System.out.println("\t Nombre d'opérandes dans la pile insuffisant");
                        }
                    } else {
                        if (BOOLEAN_STACK.size() >= 2) {
                            BOOLEAN_STACK.push(BOOLEAN_STACK.doOperation(s));
                            BOOLEAN_STACK.pushHist( String.valueOf(BOOLEAN_STACK.peek()));
                            assert BOOLEAN_STACK.peek() != null;
                            System.out.println("\t " + BOOLEAN_STACK.peek().getValue());
                        } else {
                            System.out.println("\t Nombre d'opérandes dans la pile insuffisant");
                        }
                    }
                } else { // Stockage dans la pile si la chaine entré est une valeur.
                    Boolean b = BOOLEAN_STACK.getValue(s);
                    if (!b.getValue().equals("ERROR")) {
                        BOOLEAN_STACK.push(b);
                        BOOLEAN_STACK.pushHist( String.valueOf(BOOLEAN_STACK.peek()));
                        System.out.println("\t " + BOOLEAN_STACK.peek().getValue());
                    } else {
                        System.out.println("\t Pas un booléen");
                    }
                }
            }else{//Gestion de l'assignation à une variable.
                boolean hasVariableAssignment = input.contains("=");
                String var = "";
                int startIndex;
                if (hasVariableAssignment) {
                    var = input.get(0);
                    if(containOnlyNumber(var)){
                        System.out.println("\t Nom de variable non acceptable");
                        return;
                    }
                    startIndex = 2;
                } else {
                    startIndex = 0;
                }
                for (int i = startIndex; i < input.size(); i++) {
                    String n = input.get(i);
                    n = BOOLEAN_STACK.hp(n);
                    n = BOOLEAN_STACK.var(n);

                    //Réalisation du calcul
                    if (BOOLEAN_STACK.isOperator(n)) {
                        if (BOOLEAN_STACK.size() > 1) {
                            BOOLEAN_STACK.push(BOOLEAN_STACK.doOperation(n));
                            BOOLEAN_STACK.pushHist( String.valueOf(BOOLEAN_STACK.peek()));
                        } else {
                            System.out.println("\t Nombre d'opérandes dans la pile insuffisant !");
                            finished = true;
                            break;
                        }
                    } else {
                        Boolean b = BOOLEAN_STACK.getValue(n);
                        if (!b.getValue().equals("ERROR")) {
                            BOOLEAN_STACK.push(b);
                            BOOLEAN_STACK.pushHist( String.valueOf(BOOLEAN_STACK.peek()));
                        } else {
                            finished = true;
                            break;
                        }
                    }
                }
                if (!finished) {
                    Boolean result = BOOLEAN_STACK.peek();
                    if (hasVariableAssignment) {
                        BOOLEAN_STACK.pop();
                        BOOLEAN_STACK.replaceAddValue(var, result);
                        System.out.println("\t " + var +" - " + result);
                    }else{
                        System.out.println("\t " + BOOLEAN_STACK.peek().getValue());
                    }
                }
            }
        }
    }

/*
=============================================================================================================
                                        CALCUL ALGEBRIQUE
=============================================================================================================
*/

    /**
     * Calcul d'une chaîne sous format arithmétique.
     * @param s Chaîne entrée par l'utilisateur
     */
    public static void calculateAlgebr(String s){
        ArrayList<String> input = new ArrayList<>();
        Collections.addAll(input, s.trim().split(" "));
        if(input.size()==1){
            s = DOUBLE_STACK.hp(s);
            s = DOUBLE_STACK.var(s);
            input = new ArrayList<>();
            Collections.addAll(input, s.trim().split(" "));
        }
        boolean hasVariableAssignment = input.contains("=");
        String var = "";
        int startIndex;
        if (hasVariableAssignment) {
            var = input.get(0);
            if(containOnlyNumber(var)){
                System.out.println("\t Nom de variable non acceptable");
                return;
            }
            startIndex = 2;
        } else {
            startIndex = 0;
        }
        StringBuilder n = new StringBuilder();
        if(input.size() > 1 && s.contains("!")){
            System.out.println("\t Erreur de syntaxe !variable ne peut pas être avec d'autre arguments");
            return;
        }
        for (int i = startIndex; i < input.size(); i++) {
            if (countNbPop(input) <= DOUBLE_STACK.size()) {
                if (input.get(i).equals("pop()")){
                    n.append(" ").append(DOUBLE_STACK.pop());
                }else if (input.get(i).contains("?")){
                    n.append(" ").append(DOUBLE_STACK.varI(input.get(i)));
                }
                else if(DOUBLE_STACK.varContain(input.get(i))) {
                    n.append(" ").append(DOUBLE_STACK.getValueFromVariable(input.get(i)));
                }
                else { n.append(" ").append(DOUBLE_STACK.hp(input.get(i))); }
            }
        }
        Expression e1 = new Expression(n.toString());
        double res = e1.calculate();
        if(!Double.isNaN(res)){
            DOUBLE_STACK.push(res);
            DOUBLE_STACK.pushHist( String.valueOf(DOUBLE_STACK.peek()));
            if (hasVariableAssignment) {
                DOUBLE_STACK.pop();
                DOUBLE_STACK.replaceAddValue(var, res);
                System.out.println("\t " + var +" - " + res);
            }else{
                System.out.println("\t "+ DOUBLE_STACK.peek());
            }
        }else{
            System.out.println("\t Syntaxe incorrect");
        }
    }

    private static int countNbPop(ArrayList<String> sList){
        int count = 0;
        for (String element: sList) {
            if(element.equals("pop()"))
                count++;
        }
        return count;
    }

/*
=============================================================================================================
                                        CALCUL DES DOUBLES
=============================================================================================================
*/

    /**
     * Procédure réalisant l'opération demandé en fonction de la chaîne de caractère
     * @param s Chaîne de caratère entrée par l'utilisateur
     */
    public static void calculateRPN(String s) {

        boolean finished = false;
        //Formatage de l'input
        ArrayList<String> input = new ArrayList<>();
        Collections.addAll(input, s.trim().split(" "));
        if(input.size()==1){
          s = DOUBLE_STACK.hp(s);
          s = DOUBLE_STACK.var(s);
          input = new ArrayList<>();
          Collections.addAll(input, s.trim().split(" "));
        }
        else if (input.size() > 1 && s.contains("!")){
          System.out.println("\t Erreur de syntaxe !variable ne peut pas être avec d'autre arguments");
          return;
        }
        input.removeAll(Arrays.asList(null, ""));
        if (input.size() != 0) {
            if (input.size() == 1) {
                /*
                 * Execution de l'opération si la chaîne entré est un unique opérateur.
                 * Il est nécessaire de vérifier qu'il existe assez d'opérandes dans la pile.
                 */
                if (DOUBLE_STACK.isOperator(input.get(0))) {
                    if (DOUBLE_STACK.size() >= 2) {
                        DOUBLE_STACK.push(DOUBLE_STACK.doOperation(s));
                        DOUBLE_STACK.pushHist( String.valueOf(DOUBLE_STACK.peek()));
                        System.out.println("\t " + DOUBLE_STACK.peek());
                    } else {
                        System.out.println("\t Nombre d'opérandes dans la pile insuffisant");
                    }
                } else { // Stockage dans la pile si la chaine entré est une valeur.
                    double d = DOUBLE_STACK.getValue(s);
                    if (!Double.isNaN(d)) {
                        DOUBLE_STACK.push(d);
                        DOUBLE_STACK.pushHist( String.valueOf(DOUBLE_STACK.peek()));
                        System.out.println("\t " + d);
                    }
                }
            } else {//Gestion de l'assignation à une variable.
                boolean hasVariableAssignment = input.contains("=");
                String var = "";
                int startIndex;
                if (hasVariableAssignment) {
                    var = input.get(0);
                    if(containOnlyNumber(var)){
                        System.out.println("\t Nom de variable non acceptable");
                        return;
                    }
                    startIndex = 2;
                } else {
                    startIndex = 0;
                }
                for (int i = startIndex; i < input.size(); i++) {
                    String n = input.get(i);
                    n = DOUBLE_STACK.hp(n);
                    n = DOUBLE_STACK.var(n);

                    //Réalisation du calcul
                    if (DOUBLE_STACK.isOperator(n)) {
                        if (DOUBLE_STACK.size() > 1) {
                            Double d = DOUBLE_STACK.doOperation(n);
                            if (!Double.isNaN(d)) {
                                DOUBLE_STACK.push(d);
                                DOUBLE_STACK.pushHist(String.valueOf(DOUBLE_STACK.peek()));
                            }else {
                                finished = true;
                                System.out.println("\t Opération non autorisé");
                                break;
                            }
                        } else {
                            System.out.println("\t Nombre d'opérandes dans la pile insuffisant");
                            finished = true;
                            break;
                        }
                    } else {
                        double d = DOUBLE_STACK.getValue(n);
                        if (!Double.isNaN(d)) {
                            DOUBLE_STACK.push(d);
                            DOUBLE_STACK.pushHist(String.valueOf(DOUBLE_STACK.peek()));
                        } else {
                            finished = true;
                            break;
                        }
                    }
                }
                if (!finished) {
                    double result = DOUBLE_STACK.peek();
                    if (hasVariableAssignment) {
                        DOUBLE_STACK.pop();
                        DOUBLE_STACK.replaceAddValue(var, result);
                        System.out.println("\t " + var +" - " + result);
                    }else{
                        System.out.println("\t " + DOUBLE_STACK.peek());
                    }
                }
            }
        }

    }

    /**
     * Boucle infini tant que l'utilisateur ne lance pas la commande exit
     * @param args tableau des arguments
     */
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        System.out.println("><><><><><>Démarrage de la calculatrice<><><><><><><><><><><><><><><><");
        System.out.print("> ");
        while(scan.hasNextLine()) {
            String s = scan.nextLine();
            evaluate(s);
            System.out.print("> ");
        }
        scan.close();
    }

    /**
     * Vérifie qu'une chaîne contient que des chiffre.
     * @param str Une chaîne de caractère
     * @return Vrai si la chaine ne contient que des chiffre
     */
    public static boolean containOnlyNumber(String str) {
        boolean result = false;
        String regex = "^-?(([1-9][0-9]*)|(0))(?:\\.[0-9]+)?$"; //Regex pour vérifier qu'un string ne contient que des chiffre
        Pattern p = Pattern.compile(regex); // Compile la regex
        if (str != null) { // Si la chaine est vide on renvoit faux;
            Matcher m = p.matcher(str); // Trouve un matching entre la chaine et la regex en utilisant Pattern.matcher()
            result = m.matches();
        }

        return result; // Retourne si la chaine match la regex}
    }

}
